"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var fse = require('fs-extra');

var emitCountMap = new Map();

var URLImportPlugin =
/*#__PURE__*/
function () {
  function URLImportPlugin(opts) {
    _classCallCheck(this, URLImportPlugin);

    if (!opts.manifestName) {
      throw new Error('URLImportPlugin: You MUST specify a manifestName in your options. Something unique. Like {manifestName: my-special-build}');
    }

    this.opts = Object.assign({
      publicPath: null,
      basePath: '',
      manifestName: 'unknown-project',
      fileName: 'importManifest.js',
      transformExtensions: /^(gz|map)$/i,
      writeToFileEmit: false,
      seed: null,
      filter: null,
      map: null,
      generate: null,
      sort: null,
      serialize: function serialize(manifest) {
        return "if(!window.entryManifest) {window.entryManifest = {}}; window.entryManifest[\"".concat(opts.manifestName, "\"] = ").concat(JSON.stringify(manifest, null, 2));
      }
    }, opts || {});
  }

  _createClass(URLImportPlugin, [{
    key: "getFileType",
    value: function getFileType(str) {
      str = str.replace(/\?.*/, '');
      var split = str.split('.');
      var ext = split.pop();

      if (this.opts.transformExtensions.test(ext)) {
        ext = "".concat(split.pop(), ".").concat(ext);
      }

      return ext;
    }
  }, {
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      var moduleAssets = {};
      var outputFolder = compiler.options.output.path;
      var outputFile = path.resolve(outputFolder, this.opts.fileName);
      var outputName = path.relative(outputFolder, outputFile);

      var moduleAsset = function moduleAsset(_ref, file) {
        var userRequest = _ref.userRequest;

        if (userRequest) {
          moduleAssets[file] = path.join(path.dirname(file), path.basename(userRequest));
        }
      };

      var emit = function emit(compilation, compileCallback) {
        var emitCount = emitCountMap.get(outputFile) - 1;
        emitCountMap.set(outputFile, emitCount);
        var seed = _this.opts.seed || {};
        var publicPath = _this.opts.publicPath != null ? _this.opts.publicPath : compilation.options.output.publicPath;
        var stats = compilation.getStats().toJson();
        var files = compilation.chunks.reduce(function (files, chunk) {
          return chunk.files.reduce(function (files, path) {
            var name = chunk.name ? chunk.name : null;

            if (name) {
              name = "".concat(name, ".").concat(_this.getFileType(path));
            } else {
              // For nameless chunks, just map the files directly.
              name = path;
            } // Webpack 4: .isOnlyInitial()
            // Webpack 3: .isInitial()
            // Webpack 1/2: .initial


            return files.concat({
              path: path,
              chunk: chunk,
              name: name,
              isInitial: chunk.isOnlyInitial ? chunk.isOnlyInitial() : chunk.isInitial ? chunk.isInitial() : chunk.initial,
              isChunk: true,
              isAsset: false,
              isModuleAsset: false
            });
          }, files);
        }, []); // module assets don't show up in assetsByChunkName.
        // we're getting them this way;

        files = stats.assets.reduce(function (files, asset) {
          var name = moduleAssets[asset.name];

          if (name) {
            return files.concat({
              path: asset.name,
              name: name,
              isInitial: false,
              isChunk: false,
              isAsset: true,
              isModuleAsset: true
            });
          }

          var isEntryAsset = asset.chunks.length > 0;

          if (isEntryAsset) {
            return files;
          }

          return files.concat({
            path: asset.name,
            name: asset.name,
            isInitial: false,
            isChunk: false,
            isAsset: true,
            isModuleAsset: false
          });
        }, files);
        files = files.filter(function (file) {
          // Don't add hot updates to manifest
          var isUpdateChunk = file.path.includes('hot-update'); // Don't add manifest from another instance

          var isManifest = emitCountMap.get(path.join(outputFolder, file.name)) !== undefined;
          return !isUpdateChunk && !isManifest;
        }); // Append optional basepath onto all references.
        // This allows output path to be reflected in the manifest.

        if (_this.opts.basePath) {
          files = files.map(function (file) {
            file.name = _this.opts.basePath + file.name;
            return file;
          });
        }

        if (publicPath) {
          // Similar to basePath but only affects the value (similar to how
          // output.publicPath turns require('foo/bar') into '/public/foo/bar', see
          // https://github.com/webpack/docs/wiki/configuration#outputpublicpath
          files = files.map(function (file) {
            file.path = publicPath + file.path;
            return file;
          });
        }

        files = files.map(function (file) {
          file.name = file.name.replace(/\\/g, '/');
          file.path = file.path.replace(/\\/g, '/');
          return file;
        });

        if (_this.opts.filter) {
          files = files.filter(_this.opts.filter);
        }

        if (_this.opts.map) {
          files = files.map(_this.opts.map);
        }

        if (_this.opts.sort) {
          files = files.sort(_this.opts.sort);
        }

        var manifest;

        if (_this.opts.generate) {
          manifest = _this.opts.generate(seed, files);
        } else {
          manifest = files.reduce(function (manifest, file) {
            manifest[file.name] = file.path;
            return manifest;
          }, seed);
        }

        var isLastEmit = emitCount === 0;

        if (isLastEmit) {
          var cleanedManifest = Object.entries(manifest).reduce(function (acc, _ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
                key = _ref3[0],
                asset = _ref3[1];

            if (!asset.includes('.map')) {
              return Object.assign(acc, _defineProperty({}, key, asset));
            }

            return acc;
          }, {});

          var output = _this.opts.serialize(cleanedManifest);

          compilation.assets[outputName] = {
            source: function source() {
              return output;
            },
            size: function size() {
              return output.length;
            }
          };

          if (_this.opts.writeToFileEmit) {
            fse.outputFileSync(outputFile, output);
          }
        }

        if (compiler.hooks) {
          compiler.hooks.webpackURLImportPluginAfterEmit.call(manifest);
        } else {
          compilation.applyPluginsAsync('webpack-manifest-plugin-after-emit', manifest, compileCallback);
        }
      };

      function beforeRun(compiler, callback) {
        var emitCount = emitCountMap.get(outputFile) || 0;
        emitCountMap.set(outputFile, emitCount + 1);

        if (callback) {
          callback();
        }
      }

      if (compiler.hooks) {
        var SyncWaterfallHook = require('tapable').SyncWaterfallHook;

        var pluginOptions = {
          name: 'URLImportPlugin',
          stage: Infinity
        };
        compiler.hooks.webpackURLImportPluginAfterEmit = new SyncWaterfallHook(['manifest']);
        compiler.hooks.compilation.tap('URLImportPlugin', function (compilation) {
          var usedIds = new Set();
          compilation.hooks.beforeModuleIds.tap('URLImportPlugin', function (modules) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _module = _step.value;

                if (_module._source && _module._source._value.includes('externalize')) {
                  try {
                    _module.id = _module._source._value.match(/\/\*\s*externalize\s*:\s*(\S+)\s*\*\//)[1];
                  } catch (error) {}
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          });
        });
        compiler.hooks.compilation.tap(pluginOptions, function (_ref4) {
          var hooks = _ref4.hooks;
          hooks.moduleAsset.tap(pluginOptions, moduleAsset);
        });
        compiler.hooks.emit.tap(pluginOptions, emit);
        compiler.hooks.run.tap(pluginOptions, beforeRun);
        compiler.hooks.watchRun.tap(pluginOptions, beforeRun);
      } else {
        compiler.plugin('compilation', function (compilation) {
          compilation.plugin('module-asset', moduleAsset);
        });
        compiler.plugin('emit', emit);
        compiler.plugin('before-run', beforeRun);
        compiler.plugin('watch-run', beforeRun);
      }
    }
  }]);

  return URLImportPlugin;
}();

module.exports = URLImportPlugin;