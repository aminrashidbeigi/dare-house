"use strict";

var _babelTraverse = _interopRequireDefault(require("babel-traverse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

'use-strict';
var validMagicStrings = ['webpackMode', // 'webpackMagicChunkName' gets dealt with current implementation & naming/renaming strategy
'webpackInclude', 'webpackExclude', 'webpackIgnore', 'webpackPreload', 'webpackPrefetch'];
var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;

function isUrl(string) {
  if (typeof string !== 'string') {
    return false;
  }

  var match = string.match(protocolAndDomainRE);

  if (!match) {
    return false;
  }

  var everythingAfterProtocol = match[1];

  if (!everythingAfterProtocol) {
    return false;
  }

  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
    return true;
  }

  return false;
}

var _require = require('@babel/helper-module-imports'),
    addDefault = _require.addDefault;

var path = require('path');

var visited = Symbol('visited');
var IMPORT_UNIVERSAL_DEFAULT = {
  id: Symbol('scout'),
  source: 'webpack-external-import'
};
var IMPORT_PATH_DEFAULT = {
  id: Symbol('pathId'),
  source: 'path',
  nameHint: 'path'
};

function getImportArgPath(p) {
  return p.parentPath.get('arguments')[0];
}

function trimChunkNameBaseDir(baseDir) {
  return baseDir.replace(/^[./]+|(\.js$)/g, '');
}

function getImport(p, _ref) {
  var source = _ref.source,
      nameHint = _ref.nameHint;
  return addDefault(p, source, {
    nameHint: nameHint
  });
}

function createTrimmedChunkName(t, importArgNode) {
  if (importArgNode.quasis) {
    var quasis = importArgNode.quasis.slice(0);
    var baseDir = trimChunkNameBaseDir(quasis[0].value.cooked);
    quasis[0] = Object.assign({}, quasis[0], {
      value: {
        raw: baseDir,
        cooked: baseDir
      }
    });
    quasis = quasis.map(function (quasi, i) {
      return i > 0 ? prepareQuasi(quasi) : quasi;
    });
    return Object.assign({}, importArgNode, {
      quasis: quasis
    });
  }

  var moduleName = trimChunkNameBaseDir(importArgNode.value);
  return t.stringLiteral(moduleName);
}

function prepareQuasi(quasi) {
  return Object.assign({}, quasi, {
    value: {
      raw: quasi.value.cooked,
      cooked: quasi.value.cooked
    }
  });
}

function getMagicWebpackComments(importArgNode) {
  var leadingComments = importArgNode.leadingComments;
  var results = [];

  if (leadingComments && leadingComments.length) {
    leadingComments.forEach(function (comment) {
      try {
        var validMagicString = validMagicStrings.filter(function (str) {
          return new RegExp("".concat(str, "\\w*:")).test(comment.value);
        }); // keep this comment if we found a match

        if (validMagicString && validMagicString.length === 1) {
          results.push(comment);
        }
      } catch (e) {// eat the error, but don't give up
      }
    });
  }

  return results;
}

function getMagicCommentChunkName(importArgNode) {
  var quasis = importArgNode.quasis,
      expressions = importArgNode.expressions;
  if (!quasis) return trimChunkNameBaseDir(importArgNode.value);
  var baseDir = quasis[0].value.cooked;
  var hasExpressions = expressions.length > 0;
  var chunkName = baseDir + (hasExpressions ? '[request]' : '');
  return trimChunkNameBaseDir(chunkName);
}

function getComponentId(t, importArgNode) {
  var quasis = importArgNode.quasis,
      expressions = importArgNode.expressions;
  if (!quasis) return importArgNode.value;
  return quasis.reduce(function (str, quasi, i) {
    var q = quasi.value.cooked;
    var id = expressions[i] && expressions[i].name;
    str += id ? "".concat(q, "${").concat(id, "}") : q;
    return str;
  }, '');
}

function existingMagicCommentChunkName(importArgNode) {
  var leadingComments = importArgNode.leadingComments;

  if (leadingComments && leadingComments.length && leadingComments[0].value.indexOf('importUrl') !== -1) {
    try {
      return leadingComments[0].value.trim();
    } catch (e) {
      return null;
    }
  }

  return null;
}

function idOption(t, importArgNode) {
  // if its an expression, then pass it through
  if (t.isIdentifier(importArgNode)) {
    return importArgNode;
  }

  if (t.isBinaryExpression(importArgNode)) {
    return importArgNode;
  }

  var id = getComponentId(t, importArgNode);
  return t.stringLiteral(id);
}

function fileOption(t, p) {
  return t.objectProperty(t.identifier('file'), t.stringLiteral(path.relative(__dirname, p.hub.file.opts.filename || '') || ''));
}

function loadOption(t, loadTemplate, p, importArgNode) {
  var argPath = getImportArgPath(p);
  var generatedChunkName = getMagicCommentChunkName(importArgNode);
  var otherValidMagicComments = getMagicWebpackComments(importArgNode);
  var existingChunkName = t.existingChunkName;
  var chunkName = existingChunkName || generatedChunkName;
  delete argPath.node.leadingComments;
  argPath.addComment('leading', " webpackChunkName: '".concat(chunkName, "' "));
  otherValidMagicComments.forEach(function (validLeadingComment) {
    return argPath.addComment('leading', validLeadingComment.value);
  });
  var load = loadTemplate({
    IMPORT: argPath.parent
  }).expression;
  return t.objectProperty(t.identifier('load'), load);
}

module.exports = function dynamicUrlImportPlugin(babel) {
  var t = babel.types;
  var importWhitelist = {};
  return {
    name: 'dynamic-url-imports',
    visitor: {
      Program: {
        enter: function enter(node, parent) {
          var comments = node.parent.comments || [];
          comments.forEach(function (comment) {
            if (comment && comment.value) {
              var splitComment = comment.value.split(':');

              if (splitComment[0] === 'externalize') {
                var functionToExport = splitComment[1].trim(); // props use this instead of module proto to actually export out the one single function

                var header = "\n                 \n \n                ";
                node.pushContainer('body', babel.parse(header).program.body[0]);
              }
            }
          });
        }
      },
      Identifier: function Identifier(p) {
        // only care about promise callbacks
        if (!p.isIdentifier({
          name: 'then'
        })) {
          return;
        }

        if (!p.parent || !p.parent.object || !p.parent.object.isDynamic) {
          return;
        }

        var parentPath = p.findParent(function (path) {
          return path.isCallExpression();
        });
        (0, _babelTraverse["default"])(parentPath.node, {
          ArrowFunctionExpression: function ArrowFunctionExpression(path) {
            var moduleMaps = new Set();

            if (path.isArrowFunctionExpression()) {
              if (path.node.params) {
                path.node.params.forEach(function (node) {
                  if (node.type === 'ObjectPattern') {
                    node.properties.forEach(function (property) {
                      if (!moduleMaps.has(property.key.name)) moduleMaps.add(property.key.name);
                    });
                    node.properties.length = 0;
                  }
                });
              }

              var injectedDepencency = Array.from(moduleMaps).map(function (moduleName) {
                return t.assignmentExpression('=', t.identifier("const ".concat(moduleName)), t.identifier("__webpack_require__(\"".concat(moduleName, "\")")));
              });

              try {
                var _path$get$node$body;

                (_path$get$node$body = path.get('body').node.body).unshift.apply(_path$get$node$body, _toConsumableArray(injectedDepencency));
              } catch (e) {// something is going wrong here. We need to make sure bad promises are not transformed
              }
            }
          }
        }, parentPath.scope);
      },
      Import: function Import(p) {
        if (p[visited]) return;
        p[visited] = true;
        var importArgNode = getImportArgPath(p).node;
        t.existingChunkName = existingMagicCommentChunkName(importArgNode); // no existing chunkname, no problem - we will reuse that for fixing nested chunk names

        if (importArgNode.value && !isUrl(importArgNode.value)) return;
        if (!importArgNode.value && t.existingChunkName !== 'importUrl') return;
        if (importArgNode.value) Object.assign(importWhitelist, _defineProperty({}, importArgNode.value, null));
        var universalImport = getImport(p, IMPORT_UNIVERSAL_DEFAULT); // if being used in an await statement, return load() promise

        if (p.parentPath.parentPath.isYieldExpression() // await transformed already
        || t.isAwaitExpression(p.parentPath.parentPath.node) // await not transformed already
        ) {
            var _func = t.callExpression(universalImport, [loadOption(t, loadTemplate, p, importArgNode).value, t.booleanLiteral(false)]);

            p.parentPath.replaceWith(_func);
            p.parentPath.node.isDynamic = true;
            return;
          }

        var options = idOption(t, importArgNode);
        var func = t.callExpression(universalImport, [options]);
        delete t.existingChunkName;
        p.parentPath.replaceWith(func);
        p.parentPath.node.isDynamic = true;
      }
    }
  };
};